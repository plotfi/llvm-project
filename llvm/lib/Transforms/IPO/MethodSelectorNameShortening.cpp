//===- MethodSelectorNameShortening.cpp - Shorten Class Names -------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This pass walks over all objc_msgSend calls and finds the GlobalVariable
// corresponding to the selector string. The selector string is then renamed
// with a new name generated by getNewName(). Ideally getNewname() would produce
// a smaller selector.
//
//===----------------------------------------------------------------------===//

#include "llvm/ADT/STLExtras.h"
#include "llvm/ADT/StringMap.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/ADT/StringSet.h"
#include "llvm/Analysis/ModuleSummaryAnalysis.h"
#include "llvm/Bitcode/BitcodeWriter.h"
#include "llvm/IR/CallSite.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/ModuleSummaryIndexYAML.h"
#include "llvm/InitializePasses.h"
#include "llvm/Pass.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/Path.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Transforms/IPO.h"
#include "llvm/Support/JSON.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/VirtualFileSystem.h"

#include <algorithm>
#include <fstream>
#include <sstream>
#include <string>

#define DEBUG_TYPE "method-selector-name-shortening"

using namespace llvm;

static std::string MethodSelectorNameMapFilePath;
static cl::opt<std::string, true> SelectorNameWhitelistFlag(
    "method-selector-renamer-mapping-file",
    cl::location(MethodSelectorNameMapFilePath), cl::init(""),
    cl::value_desc("filename"),
    cl::desc("ObjC Method Selector Renaming JSON Mapping File."), cl::Hidden);

namespace {

class SelectorNameMap {
  std::map<std::string, std::string> NameMap;

  SelectorNameMap() {
    llvm::SmallString<256> Filepath(MethodSelectorNameMapFilePath);
    auto File = llvm::vfs::getRealFileSystem()->getBufferForFile(Filepath);
    if (!File)
      return;

    auto Json = llvm::json::parse(File.get()->getBuffer());
    if (!Json)
      return;

    if (const json::Object *JO = Json.get().getAsObject())
      for (const auto &E : *JO)
        NameMap[E.getFirst().str()] =
            E.getSecond().getAsString().getValue().str();
  }


public:
  static SelectorNameMap &getInstance() {
    static SelectorNameMap Instance;
    return Instance;
  }

  Expected<std::string> getNewName(const std::string &Name) {
    // Not ideal, but an easy way to strip the double '\00'.
    auto I = NameMap.find(std::string(Name.c_str()));
    if (I == NameMap.end())
      return make_error<StringError>("Unexpected SelectorName: " + Name,
                                     inconvertibleErrorCode());
    return I->second;
  }
};



bool renameSelector(GlobalVariable &GV) {

  std::string NewSelectorName = [](StringRef SelectorName) -> std::string {
    auto SNM = SelectorNameMap::getInstance();
    auto NewNameOrErr = SNM.getNewName(std::string(SelectorName.str().c_str()));
    if (!NewNameOrErr) {
      consumeError(NewNameOrErr.takeError());
      LLVM_DEBUG(errs() << "Can't rename selector: " << SelectorName << "\n";);
      return "";
    }

    std::string NewName = NewNameOrErr.get();
    size_t OldArity = std::count(SelectorName.begin(), SelectorName.end(), ':');
    size_t NewArity = std::count(SelectorName.begin(), SelectorName.end(), ':');
    assert(OldArity == NewArity && "Expected Arity to match.");
    LLVM_DEBUG(errs() << "Method Selector Rename: " << SelectorName << "->"
                      << NewName << "\n";);
    return NewName + '\0';
  }(cast<ConstantDataArray>(GV.getInitializer())->getAsString());

  if (NewSelectorName == "")
    return false;

  GlobalVariable *NGV = [](GlobalVariable &GV, StringRef NewData) {
    Module &M = *GV.getParent();
    Constant *Init =
        ConstantDataArray::getString(M.getContext(), NewData, false);
    GlobalVariable *NGV = new GlobalVariable(
        M, Init->getType(), GV.isConstant(), GV.getLinkage(), Init,
        GV.getName(), nullptr /* InsertBefore */, GV.getThreadLocalMode(),
        GV.getType()->getAddressSpace(), GV.isExternallyInitialized());
    NGV->setVisibility(GV.getVisibility());
    NGV->setDLLStorageClass(GV.getDLLStorageClass());
    NGV->setUnnamedAddr(GV.getUnnamedAddr());
    NGV->setDSOLocal(GV.isDSOLocal());
    NGV->copyAttributesFrom(&GV);
    return NGV;
  }(GV, NewSelectorName);

  GV.replaceAllUsesWith(ConstantExpr::getBitCast(NGV, GV.getType()));
  GV.eraseFromParent();
  return true;
}

struct MethodSelectorNameShortening : public ModulePass {
  static char ID;

  MethodSelectorNameShortening() : ModulePass(ID) {
    initializeMethodSelectorNameShorteningPass(
        *PassRegistry::getPassRegistry());
  }

  bool runOnModule(Module &M) override {

    std::vector<GlobalVariable *> Selectors;

    for (auto &GV : M.globals()) {
      if (!GV.hasInitializer() || !GV.hasAttribute("objc_selector_unnamed"))
        continue;
      const auto *CA = dyn_cast<ConstantDataArray>(GV.getInitializer());
      if (!CA || !CA->isString())
        continue;
      Selectors.push_back(&GV);
    }

    bool Changed = false;
    for (auto *GV : Selectors)
      Changed &= renameSelector(*GV);

    return Changed;
  }
};
} // end anonymous namespace

INITIALIZE_PASS_BEGIN(MethodSelectorNameShortening,
                      "methodselectornameshortening",
                      "Method Selector Shortening", false, false)

INITIALIZE_PASS_END(MethodSelectorNameShortening,
                    "methodselectornameshortening",
                    "Method Selector Shortening", false, false)

char MethodSelectorNameShortening::ID = 0;

ModulePass *llvm::createMethodSelectorNameShorteningPass() {
  return new MethodSelectorNameShortening();
}
